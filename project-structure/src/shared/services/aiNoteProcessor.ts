import { Note, AICitation, AIModel, AIResponse } from '../types';
import { TauriAIService } from './aiService';

/**
 * AI-powered note processing and neural linking service.
 * Integrates AI capabilities with note management for intelligent connections.
 */
export class AIEnhancedNoteProcessor {
    private aiService: TauriAIService;
    private noteCache: Map<string, ProcessedNote> = new Map();

    constructor(aiService: TauriAIService) {
        this.aiService = aiService;
    }

    /**
     * Process a new note with AI enhancements
     */
    async processNote(note: Note): Promise<ProcessedNote> {
        const processed: ProcessedNote = {
            ...note,
            concepts: await this.extractConcepts(note.content),
            suggestedTags: await this.generateTags(note.content),
            relatedNotes: await this.findRelatedNotes(note),
            autoGeneratedSummary: await this.generateNoteSummary(note),
            readTimeEstimate: this.calculateReadTime(note.content),
            complexityScore: this.calculateComplexity(note.content),
            sentimentAnalysis: await this.analyzeSentiment(note.content),
            keyQuestions: await this.generateKeyQuestions(note.content),
            neuralConnections: await this.generateNeuralConnections(note)
        };

        this.noteCache.set(note.id, processed);
        return processed;
    }

    /**
     * Batch process multiple notes for AI enhancements
     */
    async processNotesBatch(notes: Note[]): Promise<ProcessedNote[]> {
        const results = await Promise.allSettled(
            notes.map(note => this.processNote(note))
        );

        return results
            .filter((result): result is PromiseFulfilledResult<ProcessedNote> => result.status === 'fulfilled')
            .map(result => result.value);
    }

    /**
     * Extract key concepts from note content
     */
    async extractConcepts(content: string): Promise<ExtractedConcept[]> {
        const prompt = `
            Analyze this text and extract the most important concepts, themes, and entities.
            Return them as a JSON array with: concept, importance (0-1), category, and brief explanation.
            
            Text: ${content.substring(0, 2000)}...
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [],
                include_citations: false,
                temperature: 0.3
            });

            // Parse AI response to extract concepts
            const concepts: ExtractedConcept[] = [];
            const lines = response.answer.split('\n');
            
            for (const line of lines) {
                if (line.includes('concept:') || line.match(/^\d+\./)) {
                    concepts.push({
                        name: this.extractConceptName(line),
                        importance: this.extractImportance(line),
                        category: this.extractCategory(line),
                        explanation: this.extractExplanation(line)
                    });
                }
            }

            return concepts.slice(0, 10); // Limit to top 10 concepts
        } catch (error) {
            console.error('Concept extraction failed:', error);
            return [];
        }
    }

    /**
     * Generate relevant tags for note content
     */
    async generateTags(content: string): Promise<string[]> {
        const prompt = `
            Suggest 5-8 relevant tags for this note content. 
            Return them as a comma-separated list. Focus on themes, topics, and key subjects.
            
            Content: ${content.substring(0, 1000)}...
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [],
                include_citations: false,
                temperature: 0.4
            });

            return response.answer
                .split(',')
                .map(tag => tag.trim().replace(/^["']|["']$/g, ''))
                .filter(tag => tag.length > 0 && tag.length < 30)
                .slice(0, 8);
        } catch (error) {
            console.error('Tag generation failed:', error);
            return [];
        }
    }

    /**
     * Find semantically related notes
     */
    async findRelatedNotes(note: Note): Promise<RelatedNote[]> {
        // First search for notes with similar content
        const relatedDocs = await this.aiService.searchRelatedDocuments(note.title, 10);
        
        // Then use AI to analyze relevance
        const prompt = `
            Given this note, analyze the search results and determine which are most related.
            Consider semantic similarity, shared concepts, and potential connections.
            Return a JSON array with: noteId, relevanceScore (0-1), and connectionType.
            
            Original Note: ${note.title}\n${note.content.substring(0, 500)}...
            
            Search Results:\n${relatedDocs.join('\n---\n')}
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [note.content],
                include_citations: false,
                temperature: 0.2
            });

            return this.parseRelatedNotes(response.answer);
        } catch (error) {
            console.error('Related notes analysis failed:', error);
            return [];
        }
    }

    /**
     * Generate automatic summary for note
     */
    async generateNoteSummary(note: Note): Promise<string> {
        const prompt = `
            Create a concise 2-3 sentence summary of this note that captures the main points.
            Focus on the core insights and key takeaways.
            
            Title: ${note.title}
            Content: ${note.content.substring(0, 1500)}...
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [],
                include_citations: false,
                temperature: 0.3,
                max_tokens: 150
            });

            return response.answer;
        } catch (error) {
            console.error('Summary generation failed:', error);
            return '';
        }
    }

    /**
     * Generate neural connections between concepts
     */
    async generateNeuralConnections(note: Note): Promise<NeuralConnection[]> {
        const concepts = await this.extractConcepts(note.content);
        
        if (concepts.length < 2) return [];

        const prompt = `
            Analyze these concepts and create meaningful connections between them.
            For each connection, identify: source concept, target concept, relationship type, and strength (0-1).
            Relationship types: defines, relates_to, contradicts, supports, enables, requires.
            
            Concepts: ${concepts.map(c => c.name).join(', ')}
            
            Return as JSON array of connections.
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [note.content],
                include_citations: false,
                temperature: 0.2
            });

            return this.parseNeuralConnections(response.answer);
        } catch (error) {
            console.error('Neural connection generation failed:', error);
            return [];
        }
    }

    /**
     * Generate key questions based on note content
     */
    async generateKeyQuestions(content: string): Promise<string[]> {
        const prompt = `
            Generate 5 thought-provoking questions based on this content.
            Questions should encourage deeper thinking and identify areas for further research.
            Return as a numbered list.
            
            Content: ${content.substring(0, 1000)}...
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [],
                include_citations: false,
                temperature: 0.5,
                max_tokens: 300
            });

            return this.parseQuestions(response.answer);
        } catch (error) {
            console.error('Question generation failed:', error);
            return [];
        }
    }

    /**
     * Analyze sentiment of note content
     */
    async analyzeSentiment(content: string): Promise<SentimentAnalysis> {
        const prompt = `
            Analyze the sentiment of this text on three dimensions:
            1. Overall sentiment (positive/negative/neutral, -1 to 1)
            2. Emotional intensity (0 to 1)
            3. Key emotions detected
            
            Return as JSON with these fields.
            
            Text: ${content.substring(0, 1000)}...
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [],
                include_citations: false,
                temperature: 0.1
            });

            return this.parseSentiment(response.answer);
        } catch (error) {
            console.error('Sentiment analysis failed:', error);
            return {
                overall: 0,
                intensity: 0.5,
                emotions: ['neutral']
            };
        }
    }

    /**
     * Calculate estimated reading time
     */
    calculateReadTime(content: string): number {
        const wordsPerMinute = 200;
        const wordCount = content.split(/\s+/).length;
        return Math.ceil(wordCount / wordsPerMinute);
    }

    /**
     * Calculate content complexity score
     */
    calculateComplexity(content: string): number {
        // Simple complexity calculation based on various factors
        const words = content.split(/\s+/);
        const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
        const avgWordsPerSentence = words.length / Math.max(sentences.length, 1);
        
        // Factors: word length, sentence length, unique words ratio
        const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;
        const uniqueWordsRatio = new Set(words.map(w => w.toLowerCase())).size / words.length;
        
        // Complexity score (0-1)
        return Math.min(1, (
            (avgWordLength / 10) * 0.3 +
            (avgWordsPerSentence / 30) * 0.4 +
            (uniqueWordsRatio * 0.3)
        ));
    }

    /**
     * Suggest improvements for note
     */
    async suggestImprovements(note: ProcessedNote): Promise<NoteImprovement[]> {
        const prompt = `
            Analyze this processed note and suggest 3-5 improvements:
            Consider clarity, structure, completeness, and engagement.
            
            Title: ${note.title}
            Content: ${note.content.substring(0, 1500)}...
            Summary: ${note.autoGeneratedSummary}
            Concepts: ${note.concepts.map(c => c.name).join(', ')}
            
            Return suggestions as JSON array with: type, description, and priority.
        `;

        try {
            const response = await this.aiService.generate({
                query: prompt,
                context_documents: [note.content],
                include_citations: false,
                temperature: 0.3
            });

            return this.parseImprovements(response.answer);
        } catch (error) {
            console.error('Improvement suggestions failed:', error);
            return [];
        }
    }

    /**
     * Generate automatic backlinks suggestions
     */
    async generateBacklinkSuggestions(noteId: string, content: string): Promise<BacklinkSuggestion[]> {
        const relatedDocs = await this.aiService.searchRelatedDocuments(content, 5);
        
        return relatedDocs.map((doc, index) => ({
            targetNoteTitle: this.extractTitleFromDocument(doc),
            targetNoteId: `doc_${index}`, // Would be real ID in implementation
            relevanceScore: Math.max(0.3, 0.8 - index * 0.15),
            suggestedAnchorText: this.extractRelevantPhrase(content, doc)
        }));
    }

    // Helper methods for parsing AI responses
    private extractConceptName(line: string): string {
        const match = line.match(/concept[:\s]*(.+)/i);
        return match ? match[1].trim() : line.replace(/^\d+\.\s*/, '').trim();
    }

    private extractImportance(line: string): number {
        const match = line.match(/importance[:\s]*([\d.]+)/i);
        return match ? parseFloat(match[1]) : 0.5;
    }

    private extractCategory(line: string): string {
        const match = line.match(/category[:\s]*(.+)/i);
        return match ? match[1].trim() : 'general';
    }

    private extractExplanation(line: string): string {
        const match = line.match(/explanation[:\s]*(.+)/i);
        return match ? match[1].trim() : '';
    }

    private parseRelatedNotes(response: string): RelatedNote[] {
        try {
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch {
            // Fallback parsing
            return [];
        }
        return [];
    }

    private parseNeuralConnections(response: string): NeuralConnection[] {
        try {
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch {
            // Fallback parsing
            return [];
        }
        return [];
    }

    private parseQuestions(response: string): string[] {
        return response
            .split('\n')
            .filter(line => line.match(/^\d+\./) || line.includes('?'))
            .map(line => line.replace(/^\d+\.\s*/, '').trim())
            .filter(q => q.length > 0);
    }

    private parseSentiment(response: string): SentimentAnalysis {
        try {
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch {
            // Default values
        }
        return {
            overall: 0,
            intensity: 0.5,
            emotions: ['neutral']
        };
    }

    private parseImprovements(response: string): NoteImprovement[] {
        try {
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch {
            // Fallback parsing
            return [];
        }
        return [];
    }

    private extractTitleFromDocument(doc: string): string {
        const match = doc.match(/Title[:\s]*(.+)/i);
        return match ? match[1].trim() : 'Unknown Document';
    }

    private extractRelevantPhrase(content: string, relatedDoc: string): string {
        // Simple implementation - find a common concept
        const contentWords = content.toLowerCase().split(/\s+/);
        const docWords = relatedDoc.toLowerCase().split(/\s+/);
        
        for (const word of contentWords) {
            if (word.length > 4 && docWords.includes(word)) {
                return word;
            }
        }
        
        return 'related concept';
    }
}

// Type definitions for enhanced note processing
export interface ProcessedNote extends Note {
    concepts: ExtractedConcept[];
    suggestedTags: string[];
    relatedNotes: RelatedNote[];
    autoGeneratedSummary: string;
    readTimeEstimate: number;
    complexityScore: number;
    sentimentAnalysis: SentimentAnalysis;
    keyQuestions: string[];
    neuralConnections: NeuralConnection[];
}

export interface ExtractedConcept {
    name: string;
    importance: number;
    category: string;
    explanation: string;
}

export interface RelatedNote {
    noteId: string;
    relevanceScore: number;
    connectionType: 'semantic' | 'conceptual' | 'temporal' | 'causal';
    sharedConcepts: string[];
}

export interface NeuralConnection {
    sourceConcept: string;
    targetConcept: string;
    relationshipType: 'defines' | 'relates_to' | 'contradicts' | 'supports' | 'enables' | 'requires';
    strength: number;
    evidence?: string;
}

export interface SentimentAnalysis {
    overall: number; // -1 to 1
    intensity: number; // 0 to 1
    emotions: string[];
}

export interface NoteImprovement {
    type: 'clarity' | 'structure' | 'completeness' | 'engagement' | 'accuracy';
    description: string;
    priority: 'high' | 'medium' | 'low';
    suggestedAction?: string;
}

export interface BacklinkSuggestion {
    targetNoteTitle: string;
    targetNoteId: string;
    relevanceScore: number;
    suggestedAnchorText: string;
}